<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><style>/*<![CDATA[*/
table{border: 1px solid gray;} td{border: 1px dotted gray;} p{margin: 3px 0 3px 0; padding: 0;} #ID_Footer{font-size: small; font-style: italic;} a{padding-right: 20px; background: URL(./icon_newwin.gif) no-repeat center right;} a[href ^= "mailto:"]{padding: 0 20px 0 0; background: URL(./icon_email.gif) no-repeat center right;} a[href ^= "nyf:"]{padding: 0 20px 0 0; background: URL(./icon_jump.gif) no-repeat center right;} 
/*]]>*/</style><title>查找树</title></head><body>
<div><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; color: #000000; line-height: 140%">二叉查找/搜索/排序树 &nbsp;BST &nbsp;(binary search/sort tree)</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; color: #333333; padding-left: 20pt">或者是一棵空树；</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt">或者是具有下列性质的二叉树：</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt">（1）若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt">（2）若它的右子树上所有结点的值均大于它的根节点的值；</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt">（3）它的左、右子树也分别为二叉排序树。</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 60pt; line-height: 140%"> &nbsp; &nbsp;</span><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 60pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; </span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 60pt; line-height: 140%"> &nbsp;</span><span style="font-family: 微软雅黑; font-size: 9pt; padding-left: 60pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; </span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; color: #ff0000; line-height: 140%">注意：对二叉查找树进行中序遍历，得到有序集合。</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; line-height: 140%">平衡二叉树</span><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%">（Self-balancing binary search tree） &nbsp;自平衡二叉查找树 &nbsp;又被称为AVL树（有别于AVL算法）</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt; line-height: 140%">它是一 棵空树</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt; line-height: 140%">或它的左右两个子树的高度差(</span><span style="font-family: 微软雅黑; font-size: 11pt; color: #ff3300; padding-left: 20pt; line-height: 140%">平衡因子</span><span style="font-family: 微软雅黑; font-size: 11pt; color: #000000; padding-left: 20pt; line-height: 140%">)的绝对值不超过1，</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt; line-height: 140%">并且左右两个子树都是一棵平衡二叉树，</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt; line-height: 140%">同时，平衡二叉树必定是二叉搜索树，反之则不一定</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt"> </span><span style="font-family: 微软雅黑; font-size: 11pt; color: #ff3300; padding-left: 20pt">平衡因子（平衡度）：</span><span style="font-family: 微软雅黑; font-size: 11pt; color: #000000; padding-left: 20pt">结点的平衡因子是结点的左子树的高度减去右子树的高度。（或反之定义）</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt"> </span><span style="font-family: 微软雅黑; font-size: 11pt; color: #ff3300; padding-left: 20pt">平衡二叉树：</span><span style="font-family: 微软雅黑; font-size: 11pt; color: #000000; padding-left: 20pt">每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; color: #ff0000; padding-left: 20pt; line-height: 140%">平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 20pt; line-height: 140%">平衡二叉树的常用实现方法有AVL、红黑树、替罪羊树、Treap、伸展树等</span></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; line-height: 140%">红黑树</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;R-B Tree，全称是Red-Black Tree，又称为&quot;红黑树&quot;，它一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">红黑树的特性:</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">（1）每个节点或者是黑色，或者是红色。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">（2）根节点是黑色。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">注意：</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; padding-left: 40pt; line-height: 140%">(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树</span></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</span></div>
<div><br /></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; line-height: 140%">B树（balanced tree）</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;你觉得平衡树，和二叉平衡树有什么差别呢？</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;与二叉平衡树相比，是多叉的</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;可以降低树的深度，提高查找效率</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt"> &nbsp; &nbsp; &nbsp; &nbsp;B树应文件系统的要求而发展起来的，大量数据存放在外存中，通常存放在硬盘中。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt"> &nbsp; &nbsp; &nbsp; &nbsp;由于是海量数据，不可能一次调入内存。因此，要多次访问外存。但硬盘的驱动受机械运动的制约，速度慢。</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt"> &nbsp; &nbsp; &nbsp; &nbsp;所以，主要矛盾变为减少访外存次数在 1972 年由 R .Bayer 和 E .Macreight &nbsp;提出用B_树作为索引组织文件。提高访问速度、减少时间</span></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; line-height: 140%">B+树</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;B+树总是到叶子结点才命中；</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; line-height: 140%">数据库的索引的默认数据结构就是采用B+树</span><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%">。</span></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; font-weight: bold; line-height: 140%">B*树</span></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp;是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针</span></div>
<div><br /></div>
<div><br /></div>
<div><span style="font-family: 微软雅黑; font-size: 11pt; line-height: 140%"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div><br /></div>
<div id="ID_Footer" style="text-align: right; margin-top: 4em; padding-top: 4px; border-top: 2px solid gray">Generated with <a href="http://www.wjjsoft.com/mybase#htmltree" target="_blank">myBase/HtmlTree Maker</a> by <a href="http://www.wjjsoft.com/#htmltree" target="_blank">Wjj Software</a></div><script type="text/javascript" language="javascript" src="jquery.js;itemlink.js"></script>
<script type="text/javascript" language="javascript" src="jquery.js"></script>
<script type="text/javascript" language="javascript" src="itemlink.js"></script></body></html>